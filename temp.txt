/* -------------------------------------------------------------------------- */
/* IMPLEMENTATION */
/* -------------------------------------------------------------------------- */

#define _UC_SET_OUT(out_param, out_val) \
    if((out_param) != NULL) (*(out_param)) = (out_val);

static inline bool _uc_utf8_overlong(uint32_t utf32_cp, size_t utf8_unit_size)
{
    switch(utf8_unit_size)
    {
        case 1:
            return false;
        case 2:
            return (utf32_cp < UC_UTF8_2B_UNIT_UC_RANGE_START);
        case 3:
            return (utf32_cp < UC_UTF8_3B_UNIT_UC_RANGE_START);
        case 4:
            return (utf32_cp < UC_UTF8_4B_UNIT_UC_RANGE_START);
        default: // undefined
            return true;
    }
}

static inline bool _uc_utf32_cp_surrogate(uint32_t utf32_cp)
{
    return ((utf32_cp >= UC_UNICODE_SURROGATE_START) &&
            (utf32_cp <= UC_UNICODE_SURROGATE_END));
}

static inline bool _uc_utf32_cp_overflow(uint32_t utf32_cp)
{
    return (utf32_cp > UC_UNICODE_MAX);
}

static bool uc_utf32_is_in_range(uint32_t utf32_codepoint, uint8_t flags)
{
    if(flags & UC_FLAG_ALLOW_SURROGATE)
    {
        return (!_uc_utf32_cp_overflow(utf32_codepoint));
    }
    else
    {
        return (!_uc_utf32_cp_overflow(utf32_codepoint) &&
                !(_uc_utf32_cp_surrogate(utf32_codepoint)));
    }
}

static uint32_t uc_utf8_to_utf32_single(const uint8_t* utf8_seq,
        size_t len, uint8_t flags, int* out_status)
{
    uint32_t _cp;
    uc_utf8_to_utf32(utf8_seq, len, &_cp, 1, flags, NULL, out_status);
    return _cp;
}

static void uc_utf32_to_utf8_single(uint32_t utf32, uint8_t flags,
        uint8_t* out_utf8_seq, size_t* out_len, int* out_status)
{
    uc_utf32_to_utf8(&utf32, 1, out_utf8_seq, 4, flags,
            NULL, out_len, out_status);
}

static void uc_utf8_to_utf32(const uint8_t* utf8_seq, size_t len,
        uint32_t* out_utf32_seq, size_t capacity, uint8_t flags,
        size_t* out_width, int* out_status)
{
    if(utf8_seq == NULL)
    {
        _UC_SET_OUT(out_width, 0);
        _UC_SET_OUT(out_status, UC_ERR_INVALID_ARG);
        return;
    }

    size_t i = 0;
    size_t counter = 0;
    size_t i_len;
    uint32_t i_cp;
    for(; i < len; counter++)
    {
        if((out_utf32_seq != NULL) && (counter >= capacity))
        {
            _UC_SET_OUT(out_width, counter);
            _UC_SET_OUT(out_status, UC_ERR_NOT_ENOUGH_CAPACITY);
            return;
        }
        
        i_len = uc_utf8_unit_len(utf8_seq[i]);
        switch(i_len)
        {
            case 1:
                i_cp = (uint32_t)(utf8_seq[i]);
                break;
            case 2:
                i_cp = ((uint32_t)(utf8_seq[i] & 0x1F)) << 6;
                break;
            case 3:
                i_cp = ((uint32_t)(utf8_seq[i] & 0x0F) << 12);
                break;
            case 4:
                i_cp = ((uint32_t)(utf8_seq[i] & 0x07) << 18);
                break;
            default:
                _UC_SET_OUT(out_width, counter);
                _UC_SET_OUT(out_status, UC_ERR_INVALID_SBYTE);
                return;
        }

        if((i + i_len) > len)
        {
            _UC_SET_OUT(out_width, counter);
            _UC_SET_OUT(out_status, UC_ERR_INVALID_SIZE);
            return;
        }

        // Process (it_len - 1) continuation bytes
        size_t j, j_shift;
        for(j = 1; j < i_len; j++)
        {
            if((utf8_seq[i + j] & 0xC0) != 0x80) // invalid continuation byte
            {
                _UC_SET_OUT(out_width, counter);
                _UC_SET_OUT(out_status, UC_ERR_INVALID_CBYTE);
                return;
            }
            j_shift = (i_len - j - 1) * 6;

            i_cp |= ((utf8_seq[i + j] & 0x3F) << j_shift);
        }
        i += j;

        // Check for overlong if needed
        if(!(flags & UC_FLAG_ALLOW_OVERLONG) && _uc_utf8_overlong(i_cp, i_len))
        {
            _UC_SET_OUT(out_width, counter);
            _UC_SET_OUT(out_status, UC_ERR_OVERLONG);
            return;
        }

        // Check for surrogate if needed
        if(!(flags & UC_FLAG_ALLOW_SURROGATE) && _uc_utf32_cp_surrogate(i_cp))
        {
            _UC_SET_OUT(out_width, counter);
            _UC_SET_OUT(out_status, UC_ERR_SURROGATE);
            return;
        }

        if(_uc_utf32_cp_overflow(i_cp))
        {
            _UC_SET_OUT(out_width, counter);
            _UC_SET_OUT(out_status, UC_ERR_INVALID_CODEPOINT);
            return;
        }

        if(out_utf32_seq != NULL)
            out_utf32_seq[counter] = i_cp;
    }

    _UC_SET_OUT(out_width, counter);
    _UC_SET_OUT(out_status, UC_SUCCESS);
}

static void uc_utf32_to_utf8(const uint32_t* utf32_seq, size_t width,
        uint8_t* out_utf8_seq, size_t capacity, uint8_t flags,
        size_t* out_width, size_t* out_len, int* out_status)
{
    if(utf32_seq == NULL)
    {
        _UC_SET_OUT(out_width, 0);
        _UC_SET_OUT(out_len, 0);
        _UC_SET_OUT(out_status, UC_ERR_INVALID_ARG);
        return;
    }

    size_t i = 0, j;
    size_t bcount = 0;
    uint32_t i_cp;
    size_t i_len;
    uint8_t i_char;
    for(; i < width; i++, bcount += i_len)
    {
        i_cp = utf32_seq[i];
        if(!(flags & UC_FLAG_ALLOW_SURROGATE) && _uc_utf32_cp_surrogate(i_cp))
        {
            _UC_SET_OUT(out_width, i);
            _UC_SET_OUT(out_len, bcount);
            _UC_SET_OUT(out_status, UC_ERR_SURROGATE);
            return;
        }
        if(_uc_utf32_cp_overflow(i_cp))
        {
            _UC_SET_OUT(out_width, i);
            _UC_SET_OUT(out_len, bcount);
            _UC_SET_OUT(out_status, UC_ERR_INVALID_CODEPOINT);
            return;
        }

        if(i_cp <= UC_UTF8_1B_UNIT_UC_RANGE_END)
        {
            i_len = 1;
            i_char = (uint8_t)i_cp;
        }
        else if(i_cp <= UC_UTF8_2B_UNIT_UC_RANGE_END)
        {
            // 0 0 00000abc defghijk
            // 1. 110abcde
            // 2. 10fghijk

            i_len = 2;
            i_char = ((uint8_t)(i_cp >> 6)) | 0xC0;
        }
        else if(i_cp <= UC_UTF8_3B_UNIT_UC_RANGE_END)
        {
            // 0 0 abcdefgh ijklmnop
            // 1. 1110abcd
            // 2. 10efghij
            // 3. 10klmnop

            i_len = 3;
            i_char = ((uint8_t)(i_cp >> 12)) | 0xE0;
        }
        else // 4 bytes
        {
            // 0 000abcde fghijklm nopqrstu
            // 1. 11110abc
            // 2. 10defghi
            // 3. 10jklmno
            // 4. 10pqrstu

            i_len = 4;
            i_char = ((uint8_t)(i_cp >> 18)) | 0xF0;
        }
        
        if(out_utf8_seq != NULL)
            out_utf8_seq[bcount] = i_char;

        if((out_utf8_seq != NULL) && ((bcount + i_len) > capacity))
        {
            _UC_SET_OUT(out_width, i);
            _UC_SET_OUT(out_len, bcount);
            _UC_SET_OUT(out_status, UC_ERR_NOT_ENOUGH_CAPACITY);
            return;
        }

        // Process continuation bytes
        size_t j_shift;
        uint8_t j_cbyte;
        for(j = 1; j < i_len; j++)
        {
            j_shift = 6 * (i_len - 1 - j);
            j_cbyte = (((uint8_t)(i_cp >> j_shift)) & 0x3F) | 0x80;

            if(out_utf8_seq != NULL) 
                out_utf8_seq[bcount + j] = j_cbyte;
        }

    }

    _UC_SET_OUT(out_width, i);
    _UC_SET_OUT(out_len, bcount);
    _UC_SET_OUT(out_status, UC_SUCCESS);
}

